// Generated by CoffeeScript 1.8.0
(function() {
  var ChildProcess, Pipe, expect, path, _exec, _spawn;

  require('./log');

  expect = require("chai").expect;

  _spawn = require("child_process").spawn;

  _exec = require("child_process").exec;

  Pipe = require("./Pipe");

  path = require('path');

  ChildProcess = (function() {
    ChildProcess.prototype.child = null;

    ChildProcess.prototype.descendants = [];

    ChildProcess.prototype.pipe = null;

    ChildProcess.prototype.command = null;

    ChildProcess.prototype.killed = false;

    function ChildProcess() {
      log.debug("ChildProcess.constructor()");
    }

    ChildProcess.prototype.exec = function(command, taskName) {
      log.debug("ChildProcess.exec()", arguments);
      expect(this.child).to.be["null"];
      expect(command).to.be.a('string');
      expect(taskName).to.be.a('string');
      this.command = taskName;
      this.child = _exec(command, (function(_this) {
        return function(err, stdout, stderr) {
          if (((err != null ? err.code : void 0) != null) && err.code !== 0) {
            log.error(("spacjam: Error: " + taskName + " exit code: ") + err.code);
          }
          if (((err != null ? err.signal : void 0) != null) && err.signal !== 0) {
            return log.error(("spacjam: Error: " + taskName + " termination signal: ") + err.signal);
          }
        };
      })(this));
      return this.pipe = new Pipe(this.child.stdout, this.child.stderr);
    };

    ChildProcess.prototype.spawn = function(command, args, options, pipeClass) {
      if (args == null) {
        args = [];
      }
      if (options == null) {
        options = {};
      }
      if (pipeClass == null) {
        pipeClass = null;
      }
      log.debug("ChildProcess.spawn()", arguments);
      expect(this.child, "ChildProcess is already running").to.be["null"];
      expect(command, "Invalid @command argument").to.be.a("string");
      expect(args, "Invalid @args argument").to.be.an("array");
      expect(options, "Invalid @options").to.be.an("object");
      this.command = path.basename(command);
      log.info("spacejam: spawning " + this.command);
      process.on('exit', (function(_this) {
        return function(code) {
          log.debug("ChildProcess.process.on 'exit': @command=" + _this.command + " @killed=" + _this.killed + " code=" + code);
          return _this.kill();
        };
      })(this));
      this.child = _spawn(command, args, options);
      if (pipeClass) {
        this.pipe = new pipeClass(this.child.stdout, this.child.stderr);
      } else {
        this.pipe = new Pipe(this.child.stdout, this.child.stderr);
      }
      return this.child.on("exit", (function(_this) {
        return function(code, signal) {
          log.debug("ChildProcess.process.on 'exit': @command=" + _this.command + " @killed=" + _this.killed + " code=" + code + " singal=" + signal);
          _this.killed = true;
          if (code != null) {
            return log.info("spacejam: " + command + " exited with code: " + code);
          } else if (signal != null) {
            return log.info("spacejam: " + command + " killed with signal: " + signal);
          } else {
            return log.error("spacejam: " + command + " exited with arguments: " + arguments);
          }
        };
      })(this));
    };

    ChildProcess.prototype.kill = function(signal) {
      var err, _ref;
      if (signal == null) {
        signal = "SIGTERM";
      }
      log.debug("ChildProcess.kill() signal=" + signal + " @command=" + this.command + " @killed=" + this.killed);
      if (this.killed) {
        return;
      }
      log.info("spacejam: killing", this.command);
      this.killed = true;
      try {
        return (_ref = this.child) != null ? _ref.kill(signal) : void 0;
      } catch (_error) {
        err = _error;
        return log.warn("spacejam: Error: While killing " + this.command + " with pid " + this.child.pid + ":\n", err);
      }
    };

    return ChildProcess;

  })();

  module.exports = ChildProcess;

}).call(this);
