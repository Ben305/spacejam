// Generated by CoffeeScript 1.8.0
(function() {
  var CLI, Spacejam, chai, expect, fs, isCoffee, path, sinon, sinonChai;

  fs = require('fs');

  path = require('path');

  chai = require("chai");

  expect = chai.expect;

  sinon = require("sinon");

  sinonChai = require("sinon-chai");

  chai.use(sinonChai);

  isCoffee = require('./isCoffee');

  if (isCoffee) {
    CLI = require('../../src/CLI');
    Spacejam = require('../../src/Spacejam');
  } else {
    CLI = require('../../lib/CLI');
    Spacejam = require('../../lib/Spacejam');
  }

  describe("CLI", function() {
    var cli, processArgv, testPackagesStub;
    this.timeout(30000);
    processArgv = null;
    cli = null;
    testPackagesStub = null;
    before(function() {
      return processArgv = process.argv;
    });
    after(function() {
      return process.argv = processArgv;
    });
    beforeEach(function() {
      var spacejam;
      process.chdir(__dirname + "/../apps/leaderboard");
      delete process.env.PORT;
      delete process.env.ROOT_URL;
      delete process.env.MONGO_URL;
      delete process.env.PACKAGE_DIRS;
      process.argv = ['coffee', path.normalize(__dirname + "/../bin/spacejam")];
      cli = new CLI();
      spacejam = cli.spacejam;
      return testPackagesStub = sinon.stub(spacejam, 'testPackages');
    });
    it("should call Spacejam.testPackages() with an empty options.packages array, if no packages where provided on the command line", function() {
      process.argv.push("test-packages");
      cli.exec();
      return expect(testPackagesStub).to.have.been.calledWith({
        packages: []
      });
    });
    it("should call Spacejam.testPackages() with options.packages set to the packages provided on the command line", function() {
      process.argv.push('test-packages', '--settings', 'settings.json', 'package1', 'package2');
      cli.exec();
      return expect(testPackagesStub).to.have.been.calledWith({
        settings: 'settings.json',
        packages: ['package1', 'package2']
      });
    });
    return describe('pidFileInit', function() {
      var exitStub, pidFile, pidPath;
      exitStub = null;
      pidFile = pidPath = null;
      beforeEach(function() {
        process.chdir(__dirname);
        pidFile = 'test.pid';
        pidPath = path.resolve('test.pid');
        if (fs.existsSync(pidFile)) {
          fs.unlinkSync(pidPath);
        }
        return exitStub = sinon.stub(process, 'exit');
      });
      afterEach(function() {
        if (exitStub != null) {
          exitStub.restore();
        }
        if (cli != null) {
          return process.removeListener('exit', cli.onProcessExit);
        }
      });
      it('should create a pid file and delete it on exit', function() {
        var pid;
        cli.pidFileInit(pidFile);
        expect(fs.existsSync(pidFile)).to.be["true"];
        pid = +fs.readFileSync(pidFile);
        expect(pid).to.equal(process.pid);
        cli.onProcessExit(0);
        return expect(fs.existsSync(pidFile)).to.be["false"];
      });
      it('should exit, if the pid file exists and the pid is alive', function() {
        fs.writeFileSync(pidPath, "" + process.pid);
        cli.pidFileInit(pidFile);
        return expect(exitStub).to.have.been.calledWith(Spacejam.DONE.ALREADY_RUNNING);
      });
      return it('should not exit, if the pid file exists but the pid is dead', function() {
        var pid;
        fs.writeFileSync(pidPath, "50000");
        cli.pidFileInit(pidFile);
        expect(exitStub).to.have.not.been.called;
        pid = +fs.readFileSync(pidFile);
        expect(pid).to.equal(process.pid);
        return cli.onProcessExit(0);
      });
    });
  });

}).call(this);
